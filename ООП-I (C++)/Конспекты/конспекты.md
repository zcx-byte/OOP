# Конспекты по C++ и ООП

## 1. Компиляция

**Этапы компиляции:**
1. **Препроцессинг** - обработка директив `#include`, `#define`, `#ifdef` и др., вставка содержимого заголовочных файлов.
2. **Преобразование в ассемблерный код**.
3. **Преобразование в машинный код** - создание объектных файлов (.o, .obj).
4. **Компоновка (линковка)** - объединение объектных файлов и библиотек в исполняемый файл.

**Компиляторы:**
- **Clang** - кроссплатформенный, детальные диагностические сообщения
- **G++/MinGW** - открытый, популярный для Linux
- **MSVC** - стандартный для Windows в Visual Studio
- **Intel C++ Compiler** - оптимизирован для процессоров Intel

**Системы сборки:**
- **CMake** - позволяет описывать процесс сборки независимо от платформы
- **Make** - классическая система для Unix-систем
- **MSBuild** - система сборки для Visual Studio

**Пример команды компиляции:**  
```bash
g++ main.cpp -o hello_world.exe -std=c++17 -Iinclude_path -Llibrary_path -lmylib
```

1. **`g++`** - имя компилятора C++ из набора GNU Compiler Collection (GCC)

2. **`main.cpp`** - имя исходного файла, который нужно скомпилировать

3. **`-o hello_world.exe`** - определяет имя выходного исполняемого файла. Без этого флага компилятор создаст файл с именем `a.out` (в Linux/macOS) или `a.exe` (в Windows)

4. **`-std=c++17`** - указывает стандарт языка C++, который будет использоваться при компиляции. В данном случае используется C++17. Другие возможные значения: `c++98`, `c++11`, `c++14`, `c++20` и т.д.

5. **`-Iinclude_path`** - добавляет путь к дополнительным заголовочным файлам (header files). Компилятор будет искать файлы, подключенные через `#include`, в указанной директории. Можно добавить несколько путей с помощью нескольких флагов `-I`.

6. **`-Llibrary_path`** - указывает пути, где компилятор будет искать библиотеки для линковки

7. **`-lmylib`** - указывает конкретную библиотеку для подключения. Компилятор автоматически преобразует это имя в полное имя файла библиотеки:
   - В Linux/macOS: ищет файл `libmylib.a` (статическая библиотека) или `libmylib.so` (динамическая)
   - В Windows: ищет файл `mylib.lib` (статическая) или `mylib.dll` (динамическая)

Порядок аргументов важен: флаги `-L` и `-l` обычно указываются после исходных файлов, чтобы линковщик мог правильно определить зависимости.

**Разделение на файлы:**
- Заголовочные файлы (.h, .hpp) содержат объявления
- CPP файлы (.cpp) содержат определения
- Защита от повторного включения: `#pragma once` или include guards

```cpp
// Заголовочный файл с защитой от повторного включения
#ifndef MY_HEADER_H
#define MY_HEADER_H
// код заголовочного файла
#endif
```

## 2. Управление памятью

**Типы памяти в программе:**
- **Статическая память** - глобальные переменные и статические переменные
- **Автоматическая память (стек)** - локальные переменные, параметры функций
- **Динамическая память (куча/heap)** - память, выделяемая через `new`

**Указатели и динамическая память:**
```cpp
int* ptr = new int;    // выделение памяти под одно значение
int* arr = new int[10]; // выделение памяти под массив
delete ptr;            // освобождение памяти для одного значения
delete[] arr;          // освобождение памяти для массива
```

**Проблемы ручного управления памятью:**
- **Утечки памяти** - забытые вызовы `delete`
- **Висячие указатели** - указатели на уже освобожденную память
- **Двойное освобождение** - повторное освобождение одной и той же памяти
- **Переполнение буфера** - выход за границы выделенной памяти

**Умные указатели (современный подход):**
- `std::unique_ptr` - единоличное владение ресурсом
- `std::shared_ptr` - совместное владение с подсчетом ссылок
- `std::weak_ptr` - неинициирующее совместное владение

```cpp
#include <memory>
std::unique_ptr<int> smartPtr = std::make_unique<int>(42);
```

**RAII (Resource Acquisition Is Initialization)** - идиома, при которой ресурсы захватываются в конструкторе и освобождаются в деструкторе.

## 3. Стиль кода

**Общие принципы:**
- **Читаемость важнее компактности**
- **Следование единому стилю** в рамках проекта
- **Самодокументируемый код** - использование понятных имен

**Именование:**
- Переменные и функции: `camelCase` или `snake_case`
- Классы: `PascalCase`
- Константы: `UPPER_SNAKE_CASE` или `kConstantStyle`
- Стараться избегать однобуквенных имен за исключением коротких циклов

**Форматирование:**
- Единообразные отступы (обычно 4 пробела)
- Фигурные скобки на новой строке или в конце предыдущей (выбрать один стиль)
- Пробелы вокруг операторов: `a = b + c`, а не `a=b+c`
- Пустые строки для разделения логических блоков кода

**Комментарии:**
- **Избегать очевидных комментариев:** `i++; // увеличиваем i на 1`
- **Объяснять "почему", а не "что":** комментировать причины принятых решений
- **Документирующие комментарии для публичных интерфейсов**:
```cpp
/// Вычисляет индекс массы тела
/// @param m масса тела в кг
/// @param h рост в метрах
/// @throws std::invalid_argument если h == 0
/// @return индекс массы тела
float bmi(float m, float h);
```

**Doxygen** - система автоматического создания документации из комментариев в коде.

#### **Основные причины:**

##### **Читаемость и понятность**
Единый стиль кода позволяет быстро ориентироваться в кодовой базе, легче находить нужные участки и понимать логику работы программы.

##### **Облегчение командной разработки**
Когда все члены команды используют один стиль, работа с общим кодом становится проще, а количество ошибок, вызванных несоответствиями, снижается.

##### **Быстрая поддержка и рефакторинг**
Стандартизированный код проще поддерживать, рефакторить и отлаживать. Новые участники проекта быстрее вникают в код, а код-ревью проходит эффективнее.

##### **Меньше ошибок и больше надежности**
Соблюдение стиля и использование линтеров помогает избегать распространённых ошибок и повышает качество кода.

##### **Предсказуемость и скорость разработки**
Унифицированный формат кода снижает «визуальный шум» и позволяет сосредоточиться на сути, а не на форматировании.


## 4. Аргументы функций

**Три способа передачи аргументов:**

1. **По значению:**
```cpp
void processByValue(int x) {
    x = 42; // изменение не влияет на аргумент вызывающей стороны
}
```
- Создается копия аргумента
- Безопасно, но может быть неэффективно для больших объектов
- Не позволяет изменить оригинальный аргумент

2. **По указателю:**
```cpp
void processByPointer(int* x) {
    if(x) *x = 42; // изменяет оригинальный аргумент
}
int value = 0;
processByPointer(&value); // value станет 42
```
- Передается адрес переменной
- Требует проверки на null
- Позволяет изменить оригинальный аргумент

3. **По ссылке:**
```cpp
void processByReference(int& x) {
    x = 42; // изменяет оригинальный аргумент
}
int value = 0;
processByReference(value); // value станет 42
```
- Синтаксически похоже на передачу по значению
- Не требует разыменования внутри функции
- Не может быть null (если только не используется ссылка на указатель)

**Константные ссылки** - предпочтительный способ передачи больших объектов для чтения:
```cpp
void print(const std::string& text) {
    std::cout << text;
}
```

## 5. Аргументы по умолчанию

**Синтаксис:**
```cpp
void createWindow(int width = 800, int height = 600, bool fullscreen = false) {
    // код создания окна
}
```

**Правила:**
- Аргументы по умолчанию должны идти **после** обычных аргументов
- Значения по умолчанию вычисляются во время компиляции
- Одна и та же функция не может иметь разные значения по умолчанию в разных местах программы

**Вызовы функции с аргументами по умолчанию:**
```cpp
createWindow();               // 800, 600, false
createWindow(1024);           // 1024, 600, false
createWindow(1024, 768);      // 1024, 768, false
createWindow(1024, 768, true); // 1024, 768, true
```

**Рекомендации:**
- Использовать только для аргументов, которые часто принимают одно и то же значение
- Не использовать "неожиданные" значения по умолчанию
- Избегать сложных выражений в значениях по умолчанию
- Предпочитать перегрузку функций вместо нескольких аргументов по умолчанию

**Важно:** Значения по умолчанию указываются в объявлении функции (обычно в заголовочном файле), а не в определении.

## 6. Обработка исключений

**Основные конструкции:**
- `try` - блок кода, в котором могут возникнуть исключения
- `catch` - обработчик исключений определенного типа
- `throw` - генерация исключения

```cpp
try {
    // код, который может вызвать исключение
    if (denominator == 0) {
        throw std::invalid_argument("Division by zero");
    }
    result = numerator / denominator;
} catch (const std::invalid_argument& e) {
    // обработка исключения
    std::cerr << "Invalid argument: " << e.what() << std::endl;
} catch (const std::exception& e) {
    // обработка других стандартных исключений
    std::cerr << "Standard exception: " << e.what() << std::endl;
} catch (...) {
    // обработка всех остальных исключений
    std::cerr << "Unknown exception occurred" << std::endl;
}
```

**Типы исключений:**
- Стандартные исключения из `<stdexcept>`:
  - `std::exception` - базовый класс
  - `std::runtime_error`, `std::logic_error` - категории
  - `std::invalid_argument`, `std::out_of_range`, `std::bad_alloc` и др.

**noexcept** - спецификатор, указывающий, что функция не генерирует исключений:
```cpp
void cleanup() noexcept {
    // код очистки ресурсов
}
```

**Обработка ошибок ввода:**
```cpp
std::cin.exceptions(std::istream::failbit);
try {
    int x;
    std::cin >> x;
} catch (const std::ios_base::failure& e) {
    std::cerr << "Input error: " << e.what() << std::endl;
}
```

**Рекомендации:**
- Использовать исключения для обработки исключительных ситуаций, а не для управления потоком программы
- Ловить исключения по константной ссылке: `catch (const std::exception& e)`
- Предпочитать стандартные исключения вместо встроенных типов
- Освобождать ресурсы в деструкторах (RAII), а не в обработчиках исключений

## 7. Указатели

**Объявление и инициализация:**
```cpp
int x = 10;
int* ptr = nullptr;  // современный способ инициализации пустого указателя
int* ptr2 = &x;      // получение адреса переменной
```

**Операции с указателями:**
- `*ptr` - разыменование (получение значения по адресу)
- `ptr->member` - доступ к члену класса/структуры через указатель
- `ptr + n` - арифметика указателей (смещение на n элементов)

**Виды указателей:**
- Указатель на константное значение: `const int* ptr`
- Константный указатель: `int* const ptr`
- Константный указатель на константное значение: `const int* const ptr`

**Указатели на функции:**
```cpp
// Синтаксис: возвращаемый_тип (*имя_указателя)(параметры)
int (*funcPtr)(int, int) = nullptr;

// Пример использования
int add(int a, int b) { return a + b; }
funcPtr = add;
int result = funcPtr(3, 4); // result = 7
```

**Современные альтернативы:**
- `std::function` - обобщенный указатель на функцию
- Лямбда-функции - анонимные функции, которые могут захватывать контекст
- Умные указатели - автоматическое управление памятью

**Типичные проблемы:**
- **Висячие указатели** - указатели на освобожденную память
- **Утечки памяти** - забытые вызовы `delete`
- **Несоответствие типов** - небезопасное приведение типов
- **Null pointer dereference** - разыменование нулевого указателя

## 8. Форматирование

**Стандартные средства форматирования (до C++20):**

1. **Манипуляторы из `<iomanip>`:**
```cpp
#include <iomanip>
std::cout << std::setw(10) << std::setfill('0') << 42 << std::endl;
// Вывод: 0000000042
```

2. **Флаги потока:**
```cpp
std::cout << std::fixed << std::setprecision(2) << 3.14159 << std::endl;
// Вывод: 3.14
```

**C++20: `std::format`**
```cpp
#include <format>
std::string s = std::format("Value: {:.2f}", 3.14159);
// s = "Value: 3.14"

std::string date = std::format("{:04d}-{:02d}-{:02d}", 2023, 12, 25);
// date = "2023-12-25"
```

**Локализация вывода:**
```cpp
#include <locale>
std::cout.imbue(std::locale("")); // использование локали системы
std::cout << 123456789 << std::endl;
// Вывод зависит от локали: "123,456,789" или "123 456 789"
```

**Форматирование для удобочитаемости:**
- Разделение больших чисел на группы: `1'000'000`
- Использование префиксов для чисел в разных системах счисления:
  - `0x1A` - шестнадцатеричное
  - `0b1010` - двоичное
  - `0755` - восьмеричное

**Рекомендации:**
- Предпочитать `std::format` (C++20) для сложного форматирования
- Использовать манипуляторы для простых задач форматирования вывода
- Разделять логику форматирования от логики вычислений
- Для многократного использования одинакового формата создавать функции-форматтеры

## 9. std::vector

**Основные возможности:**
```cpp
#include <vector>
std::vector<int> vec;           // пустой вектор
std::vector<int> vec2(10, 5);   // 10 элементов со значением 5
std::vector<int> vec3 = {1, 2, 3, 4, 5}; // инициализация списком
```

**Доступ к элементам:**
```cpp
vec.push_back(42);      // добавление в конец
vec[0] = 10;            // доступ по индексу (без проверки границ)
vec.at(0) = 10;         // доступ по индексу с проверкой границ
vec.front() = 1;        // доступ к первому элементу
vec.back() = 100;       // доступ к последнему элементу
```

**Изменение размера:**
```cpp
vec.resize(20);         // изменение размера до 20 элементов
vec.reserve(100);       // резервирование памяти для 100 элементов
vec.shrink_to_fit();    // освобождение неиспользуемой памяти
vec.clear();            // очистка вектора
```

**Итерация:**
```cpp
// Традиционный цикл
for (size_t i = 0; i < vec.size(); ++i) {
    std::cout << vec[i] << " ";
}

// Range-based for (C++11)
for (int value : vec) {
    std::cout << value << " ";
}

// С итераторами
for (auto it = vec.begin(); it != vec.end(); ++it) {
    std::cout << *it << " ";
}
```

**Эффективность:**
- **Добавление в конец** - амортизированно O(1)
- **Удаление из конца** - O(1)
- **Добавление/удаление в начале или середине** - O(n)
- При переполнении емкости выделяется новая память (обычно в 2 раза больше) и элементы копируются

**Рекомендации:**
- Резервировать память заранее с помощью `reserve()`, если известен примерный размер
- Предпочитать `emplace_back()` вместо `push_back()` для избежания лишних копий
- Использовать `at()` вместо `operator[]` в отладочной версии для проверки границ
- Избегать частых вызовов `resize()` и `reserve()` внутри критических секций кода

## 10. Рефакторинг

**Основные техники рефакторинга:**

1. **Извлечение метода** - выделение части кода в отдельную функцию
```cpp
// Было
void process() {
    // много кода
    double sum = 0;
    for (int i = 0; i < size; i++) {
        sum += data[i];
    }
    double avg = sum / size;
    // больше кода
}

// Стало
double calculateAverage(const std::vector<double>& data) {
    double sum = 0;
    for (double value : data) {
        sum += value;
    }
    return sum / data.size();
}
```

2. **Замена магических чисел константами:**
```cpp
// Было
if (status == 3) { /*...*/ }

// Стало
const int STATUS_COMPLETED = 3;
if (status == STATUS_COMPLETED) { /*...*/ }
```

3. **Замена условий полиморфизмом** - замена множественных `if-else` или `switch` на виртуальные методы.

4. **Инкапсуляция полей** - замена публичных полей класса на геттеры и сеттеры.

5. **Объединение дублирующегося кода** - выделение повторяющихся фрагментов в отдельные функции.

**Принципы рефакторинга:**
- **Не добавлять новую функциональность** во время рефакторинга
- **Делать маленькие шаги** и часто проверять работоспособность
- **Использовать систему контроля версий** для отката изменений при необходимости
- **Писать тесты** перед рефакторингом для обеспечения сохранения функциональности

**Признаки, указывающие на необходимость рефакторинга:**
- Длинные методы (более 20-30 строк)
- Большие классы (более 200-300 строк)
- Дублирование кода
- Сложная вложенность условий
- Множественные ответственности у одного класса/метода
- Слабая или отсутствующая инкапсуляция
- Жесткая связанность компонентов

**Автоматизация рефакторинга:**
- Современные IDE (Visual Studio, CLion, VS Code) предоставляют инструменты для автоматизации базовых операций рефакторинга
- Статические анализаторы кода (CppCheck, PVS-Studio) могут указывать на места для улучшения

## 11. std::string

**Создание и инициализация:**
```cpp
#include <string>
std::string s1;                     // пустая строка
std::string s2 = "Hello";           // инициализация C-строкой
std::string s3(5, 'a');             // "aaaaa"
std::string s4 = s2 + " World";     // конкатенация
std::string s5 = R"(Raw string)";   // сырая строка (C++11)
```

**Доступ к символам:**
```cpp
char c = s2[0];        // 'H', без проверки границ
char c2 = s2.at(0);    // 'H', с проверкой границ
char c3 = s2.front();  // 'H', первый символ
char c4 = s2.back();   // 'o', последний символ
```

**Основные операции:**
```cpp
// Размер и проверка на пустоту
size_t len = s2.length(); // или s2.size()
bool empty = s2.empty();

// Поиск подстрок
size_t pos = s2.find("el"); // 1
size_t npos = s2.find("xyz"); // std::string::npos

// Извлечение подстрок
std::string sub = s2.substr(1, 3); // "ell"

// Модификация
s2.insert(5, ",");     // Вставка
s2.erase(5);           // Удаление с позиции 5 до конца
s2.replace(0, 5, "Hi"); // Замена

// Сравнение
bool equal = (s2 == "Hello");
bool less = (s2 < "World");
```

**Преобразование в C-строку:**
```cpp
const char* c_str = s2.c_str(); // завершается нулевым символом
```

**Строковые потоки (для форматирования):**
```cpp
#include <sstream>
std::ostringstream oss;
oss << "Value: " << 3.14 << ", Status: " << true;
std::string formatted = oss.str(); // "Value: 3.14, Status: 1"
```

**Рекомендации:**
- Предпочитать `std::string` вместо C-строк (`char*`) при работе со строками
- Использовать `reserve()` для предотвращения частых перераспределений памяти
- Использовать `at()` вместо `operator[]` в отладочной версии для проверки границ
- Избегать копирования больших строк - передавать по константной ссылке: `const std::string&`

## 12. Перечисления

**Традиционные перечисления (enum):**
```cpp
enum Color {
    RED,
    GREEN,
    BLUE
};

Color c = RED; // OK
int i = RED;   // Неявное преобразование в int (может быть опасно)
```

**Слабые места традиционных перечислений:**
- Не имеют собственного пространства имен (конфликты имен)
- Неявно преобразуются в целочисленные типы
- Нельзя указать базовый тип

**Современные перечисления (enum class, C++11):**
```cpp
enum class Status {
    SUCCESS,
    FAILURE,
    PENDING
};

Status s = Status::SUCCESS; // Обязательно указание области видимости
int i = static_cast<int>(Status::SUCCESS); // Явное преобразование
```

**Преимущества enum class:**
- Имеют собственное пространство имен
- Не преобразуются неявно в целочисленные типы
- Можно указать базовый тип:
```cpp
enum class SmallEnum : std::uint8_t {
    A, B, C
};
```

**Практическое применение:**
- Замена "магических чисел" осмысленными именами
- Создание типобезопасных наборов связанных констант
- Определение состояний конечных автоматов
- Определение флагов и опций

**Пример использования в switch:**
```cpp
enum class LogLevel {
    DEBUG,
    INFO,
    WARNING,
    ERROR
};

void log(LogLevel level, const std::string& message) {
    switch (level) {
        case LogLevel::DEBUG:   std::cout << "[DEBUG] "; break;
        case LogLevel::INFO:    std::cout << "[INFO] "; break;
        case LogLevel::WARNING: std::cout << "[WARNING] "; break;
        case LogLevel::ERROR:   std::cout << "[ERROR] "; break;
    }
    std::cout << message << std::endl;
}
```

## 13. Приведение типов

**C-style cast:**
```cpp
int a = 10;
double b = (double)a; // C-style cast
```
- Не проверяется на этапе компиляции
- Небезопасно
- Не рекомендуется в современном C++

**C++-стиль приведений:**

1. **static_cast** - базовое приведение для связанных типов:
```cpp
double d = 3.14;
int i = static_cast<int>(d); // 3

Base* base = static_cast<Base*>(derived); // Вверх по иерархии наследования
```

2. **dynamic_cast** - безопасное приведение в иерархии наследования (требует полиморфизма):
```cpp
Base* base = new Derived();
Derived* derived = dynamic_cast<Derived*>(base);
if (derived) {
    // Приведение успешно
}
```

3. **const_cast** - изменение const-квалификатора:
```cpp
const int a = 10;
int* b = const_cast<int*>(&a); // Осторожно! Может привести к UB
```

4. **reinterpret_cast** - низкоуровневое приведение (крайне осторожно!):
```cpp
int i = 42;
double* d = reinterpret_cast<double*>(&i); // Опасно!
```

**Неявные преобразования:**
```cpp
int i = 10;
double d = i; // Неявное преобразование
```

**Explicit конструкторы:**
```cpp
class MyClass {
public:
    explicit MyClass(int x) : value(x) {} // Запрещает неявное преобразование
private:
    int value;
};

MyClass obj1(10);    // OK
MyClass obj2 = 10;   // Ошибка из-за explicit
```

**Рекомендации:**
- Предпочитать C++-стиль приведений вместо C-style cast
- Использовать самый конкретный тип приведения для задачи
- Избегать `reinterpret_cast` за исключением специфических случаев (низкоуровневое программирование)
- Использовать `explicit` для конструкторов с одним параметром, чтобы избежать неожиданных неявных преобразований
- По возможности избегать приведений типов вообще, используя шаблоны или полиморфизм

## 14. Перегрузка операторов

**Когда перегружать операторы:**
- Когда семантика оператора интуитивно понятна для типа
- Когда оператор улучшает читаемость кода
- Когда оператор соответствует математической или логической операции над объектами

**Не следует перегружать операторы:**
- Когда семантика неочевидна (например, перегружать `+` для соединения двух файлов)
- Когда оператор меняет свое обычное поведение (например, `+` выполняет вычитание)

**Два способа перегрузки:**

1. **Как метод класса:**
```cpp
class Vector {
public:
    Vector operator+(const Vector& other) const {
        return Vector(x + other.x, y + other.y);
    }
private:
    double x, y;
};

Vector v1, v2;
Vector v3 = v1 + v2; // Вызывает v1.operator+(v2)
```

2. **Как свободная функция:**
```cpp
class Complex {
public:
    double real, imag;
};

Complex operator+(const Complex& a, const Complex& b) {
    return {a.real + b.real, a.imag + b.imag};
}

Complex c1, c2;
Complex c3 = c1 + c2; // Вызывает operator+(c1, c2)
```

**Операторы, которые могут быть только методами:**
- `=`, `()`, `[]`, `->`

**Особые случаи:**

1. **Операторы инкремента/декремента:**
```cpp
class Counter {
public:
    // Префиксный инкремент
    Counter& operator++() {
        ++value;
        return *this;
    }
    
    // Постфиксный инкремент (фиктивный параметр int)
    Counter operator++(int) {
        Counter temp = *this;
        ++value;
        return temp;
    }
private:
    int value;
};
```

2. **Оператор вывода:**
```cpp
std::ostream& operator<<(std::ostream& os, const MyClass& obj) {
    os << obj.toString();
    return os;
}
```

**Рекомендации:**
- Реализовывать операторы как методы, если левый операнд должен быть изменен
- Реализовывать операторы как свободные функции для обеспечения симметрии (особенно для арифметических операторов)
- Следовать принципу наименьшего удивления - операторы должны вести себя так, как ожидает пользователь
- Перегружать парные операторы вместе (например, `==` и `!=`, `<` и `>`)
- Для операторов сравнения в C++20 можно использовать синтаксис "spaceship" operator `<=>`

## 15. Правило пяти (и правило нуля)

**Правило пяти:** Если класс определяет один из следующих методов, он должен явно определить все пять:

1. **Деструктор**
2. **Конструктор копирования**: `ClassName(const ClassName&)`
3. **Оператор присваивания копированием**: `ClassName& operator=(const ClassName&)`
4. **Конструктор перемещения (C++11)**: `ClassName(ClassName&&)`
5. **Оператор присваивания перемещением (C++11)**: `ClassName& operator=(ClassName&&)`

**Почему нужно правило пяти?**
При управлении ресурсами (память, файлы, сокеты и т.д.) компилятор-сгенерированные копирующие операции могут привести к:
- Утечкам памяти
- Двойному освобождению памяти
- Повреждению данных
- Поверхностному копированию вместо глубокого

**Пример реализации правила пяти:**
```cpp
class MyString {
private:
    char* data;
    size_t length;
    
public:
    // Конструктор
    MyString(const char* str) { /*...*/ }
    
    // 1. Деструктор
    ~MyString() {
        delete[] data;
    }
    
    // 2. Конструктор копирования
    MyString(const MyString& other) {
        length = other.length;
        data = new char[length + 1];
        std::strcpy(data, other.data);
    }
    
    // 3. Оператор присваивания копированием
    MyString& operator=(const MyString& other) {
        if (this != &other) {
            delete[] data;
            length = other.length;
            data = new char[length + 1];
            std::strcpy(data, other.data);
        }
        return *this;
    }
    
    // 4. Конструктор перемещения
    MyString(MyString&& other) noexcept 
        : data(other.data), length(other.length) {
        other.data = nullptr;
        other.length = 0;
    }
    
    // 5. Оператор присваивания перемещением
    MyString& operator=(MyString&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            length = other.length;
            other.data = nullptr;
            other.length = 0;
        }
        return *this;
    }
};
```

**Правило нуля (современный подход):**
Вместо ручной реализации "большой пятерки" лучше использовать композицию с уже готовыми классами, которые правильно реализуют эти операции:

```cpp
class BetterString {
private:
    std::string data; // std::string уже правильно реализует "большую пятерку"
    
public:
    // Нет необходимости реализовывать деструктор, конструкторы копирования/перемещения,
    // операторы присваивания - компилятор сгенерирует правильные версии
    BetterString(const char* str) : data(str) {}
};
```

**Применение `=default` и `=delete`:**
```cpp
class NonCopyable {
public:
    NonCopyable() = default; // Явно указать, что нужен конструктор по умолчанию
    
    // Запретить копирование
    NonCopyable(const NonCopyable&) = delete;
    NonCopyable& operator=(const NonCopyable&) = delete;
};
```

## 16. Вложенные классы

**Синтаксис и область видимости:**
```cpp
class Outer {
private:
    int outerField;
    
public:
    class Nested {
    private:
        int nestedField;
        
    public:
        void accessOuter(Outer& outer) {
            // Доступ к приватным членам внешнего класса
            outer.outerField = 42; 
        }
    };
    
    void accessNested(Nested& nested) {
        // Доступ к приватным членам вложенного класса
        nested.nestedField = 100;
    }
};
```

**Особенности вложенных классов:**
- Вложенный класс имеет доступ ко всем членам внешнего класса, включая приватные
- Внешний класс имеет доступ ко всем членам вложенного класса
- Вложенный класс не имеет доступа к конкретному экземпляру внешнего класса (только через явное указание)

**Использование вложенных классов:**

1. **Вспомогательные классы:**
```cpp
class LinkedList {
public:
    class Iterator {
    public:
        // Методы итератора
    };
    
    Iterator begin() { /*...*/ }
    Iterator end() { /*...*/ }
};
```

2. **Инкапсуляция реализации:**
```cpp
class Database {
private:
    class Connection {
        // Детали реализации соединения
    };
    
    Connection* currentConnection;
public:
    // Публичный интерфейс не показывает детали Connection
};
```

3. **Объявление вложенного класса в заголовке, определение в .cpp файле:**
```cpp
// Database.h
class Database {
public:
    class Connection; // Предварительное объявление
    void connect(Connection* conn);
};

// Database.cpp
class Database::Connection {
    // Полное определение
};
```

**Дружественные отношения:**
```cpp
class Outer {
private:
    class PrivateNested {
        // Только Outer имеет доступ к PrivateNested
    };
    
    friend class FriendClass; // FriendClass получает доступ ко всем вложенным классам
};
```

**Современный подход:** Предпочитать вложенные классы для логически связанных сущностей, которые не используются за пределами внешнего класса. Для общих типов лучше использовать отдельные классы в том же пространстве имен.

## 17. inline

**Назначение `inline`:**
- Подсказка компилятору встраивать код функции в место вызова вместо обычного вызова
- Позволяет определять функции в заголовочных файлах без нарушения правила одного определения (ODR)

**Где применяется `inline`:**

1. **Функции, определенные внутри класса:**
```cpp
class MyClass {
public:
    int getValue() const { return value; } // Автоматически inline
private:
    int value;
};
```

2. **Явное указание `inline` для функций в заголовочных файлах:**
```cpp
// my_header.h
inline int square(int x) {
    return x * x;
}
```

3. **Переменные в заголовочных файлах (C++17):**
```cpp
// my_header.h
inline int globalCounter = 0; // Можно определить в заголовке
```

**Особенности и ограничения:**
- `inline` - это только подсказка компилятору, он может проигнорировать её
- Компилятор сам решает, какие функции встраивать на основе эвристик
- Большие функции редко встраиваются компилятором
- Рекурсивные функции не могут быть встроенными
- Виртуальные функции обычно не встраиваются (кроме случаев, когда компилятор может определить конкретный тип во время компиляции)

**Производительность:**
- **Плюсы:** Уменьшение накладных расходов на вызов функции, возможность дополнительных оптимизаций
- **Минусы:** Увеличение размера кода, возможное ухудшение кэширования инструкций

**Современная практика:**
- Не использовать `inline` явно для оптимизации производительности
- Доверять компилятору в решении о встраивании
- Использовать `inline` для определения функций в заголовочных файлах
- В C++17 и новее использовать `inline` переменные вместо extern переменных с определением в .cpp файле

## 18. Markdown

**Основной синтаксис:**

1. **Заголовки:**
```markdown
# Заголовок первого уровня
## Заголовок второго уровня
### Заголовок третьего уровня
```

2. **Форматирование текста:**
```markdown
*Курсив* или _Курсив_
**Полужирный** или __Полужирный__
***Полужирный курсив*** или ___Полужирный курсив___
~~Зачеркнутый текст~~
```

3. **Списки:**
```markdown
* Ненумерованный список
* Пункт 2
  * Вложенный пункт

1. Нумерованный список
2. Пункт 2
   1. Вложенный нумерованный список
```

4. **Ссылки и изображения:**
```markdown
[Текст ссылки](https://example.com)
![Альтернативный текст](image.jpg "Подсказка")

[Ссылка на раздел в документе](#заголовок-второго-уровня)
```

5. **Код:**
```markdown
Встроенный `код` в тексте.

Блок кода:
```cpp
#include <iostream>
int main() {
    std::cout << "Hello, World!" << std::endl;
    return 0;
}
```
```

6. **Цитаты:**
```markdown
> Это цитата
> Она может занимать несколько строк
```

7. **Горизонтальная линия:**
```markdown
---
или
***
```

8. **Таблицы:**
```markdown
| Заголовок 1 | Заголовок 2 |
|------------|------------|
| Ячейка 1   | Ячейка 2   |
| Ячейка 3   | Ячейка 4   |
```

**Продвинутые возможности:**
- **Сноски:** `Текст[^1]` и `[^1]: Текст сноски`
- **Определения:** 
```markdown
Термин
: Определение термина
```
- **Диаграммы (в некоторых реализациях):**
```mermaid
graph TD;
    A-->B;
    A-->C;
    B-->D;
    C-->D;
```

**Рекомендации по оформлению документации кода:**
- Использовать Markdown для README файлов
- Документировать API с помощью Doxygen-совместимого синтаксиса
- Использовать таблицы для представления параметров функций и их описаний
- Приводить примеры использования в блоках кода
- Использовать относительные пути для изображений и других ресурсов

## 19. Выравнивание памяти

**Что такое выравнивание памяти:**
- Требование процессора обращаться к данным по адресам, кратным их размеру
- Например, 4-байтовое значение должно начинаться с адреса, кратного 4

**Последствия невыравненного доступа:**
- На некоторых архитектурах (x86) - снижение производительности
- На других (ARM, SPARC) - аппаратное исключение и аварийное завершение программы

**Выравнивание в структурах и классах:**
```cpp
struct BadAlignment {
    char c;     // 1 байт
    double d;   // 8 байт, требует выравнивания на 8 байт
    int i;      // 4 байта
};

// Компилятор добавит 7 байт выравнивания после char
// sizeof(BadAlignment) = 24 байта (1 + 7(padding) + 8 + 4 + 4(padding))
```

**Оптимизация выравнивания:**
```cpp
struct GoodAlignment {
    double d;   // 8 байт
    int i;      // 4 байта
    char c;     // 1 байт
};

// sizeof(GoodAlignment) = 16 байт (8 + 4 + 1 + 3(padding))
```

**Явное управление выравниванием (C++11 и новее):**
```cpp
// Выравнивание с помощью alignas
struct alignas(16) SSEData {
    float values[4];
};

// Атрибуты компилятора (GCC/Clang)
struct __attribute__((aligned(16))) SSEDataGCC {
    float values[4];
};

// Атрибуты компилятора (MSVC)
__declspec(align(16)) struct SSEDataMSVC {
    float values[4];
};
```

**Стандартные средства:**
```cpp
#include <cstddef>
#include <memory>

// Получение выравнивания типа
constexpr size_t alignment = alignof(double); // 8 на большинстве платформ

// Выделение выровненной памяти
void* buffer = std::aligned_alloc(16, 64); // Выравнивание 16, размер 64 байта
std::free(buffer);

// std::align (C++11) - для выравнивания указателя
void* ptr = std::malloc(100);
void* aligned_ptr;
std::size_t space = 100;
std::align(16, 64, ptr, space); // Выровнять ptr для 64-байтного объекта с выравниванием 16
```

**Важные замечания:**
- Размер структуры не всегда равен сумме размеров ее полей из-за выравнивания
- Порядок полей влияет на размер структуры и эффективность использования памяти
- Для сериализации/десериализации данных или работы с сетевыми протоколами может потребоваться упаковка структур (packed structs) с отключенным выравниванием
- В многопоточных программах выравнивание критически важно для атомарных операций

**Практические рекомендации:**
- Группировать поля по размеру (от больших к маленьким)
- Учитывать выравнивание при работе с SIMD-инструкциями (SSE, AVX)
- Использовать инструменты профилирования для анализа кэш-эффективности
- Избегать частого выделения/освобождения мелких объектов с разным выравниванием